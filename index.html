<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Random Cuber</title>
    <style>
body {
  margin: 0;
}
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://rawcdn.githack.com/mrdoob/three.js/r128/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js" integrity="sha512-avLcnGxl5mqAX/wIKERdb1gFNkOLHh2W5JNCfJm5OugpEPBz7LNXJJ3BDjjwO00AxEY1MqdNjtEmiYhKC0ld7g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script>
let camera, scene, renderer, controls;
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let moveUp = true;
let velocityY = 0;

const gravity = -9.81;
const jumpSpeed = 5;
const speed = 4;

let cubes = [];
const playerBox = new THREE.Box3();

let world;
let playerBody;
let bullets = [];

init();
animate();

function init() {
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);
  scene.add(new THREE.GridHelper(100, 100));

  let light = new THREE.PointLight(0xffffff, 1);
  camera.add(light);
  scene.add(camera);

  world = new CANNON.World();
  world.gravity.set(0, gravity, 0);
  world.broadphase = new CANNON.NaiveBroadphase();
  world.solver.iterations = 10;

  createGround();

  playerBody = new CANNON.Body({
    mass: 5,
    position: new CANNON.Vec3(0, 1.8, 0),
    shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.9, 0.5))
  });
  world.addBody(playerBody);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new THREE.PointerLockControls(camera, renderer.domElement);
  document.addEventListener('click', () => controls.lock());
  controls.addEventListener('lock', onPointerLockChange);
  controls.addEventListener('unlock', onPointerLockChange);
  controls.getObject().position.set(0, 1.8, 0);

  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);

  window.addEventListener('resize', onWindowResize);

  playerBody.addEventListener('collide', (e) => {
    const contact = e.contact;
    if (contact.ni.y > 0.5) { // Top of the cube was hit
      moveUp = false;
    }
  });
}

function onKeyDown(event) {
  switch (event.code) {
    case 'KeyW':
      moveForward = true;
    break;
    case 'KeyS':
      moveBackward = true;
    break;
    case 'KeyA':
      moveLeft = true;
    break;
    case 'KeyD':
      moveRight = true;
    break;
    case 'Space':
      if (!moveUp && controls.getObject().position.y <= 1.8) {
      moveUp = true;
      playerBody.applyImpulse(new CANNON.Vec3(0, jumpSpeed * playerBody.mass, 0), playerBody.position);
    }
    break;
  }
}

function onKeyUp(event) {
  switch (event.code) {
    case 'KeyW':
      moveForward = false;
    break;
    case 'KeyS':
      moveBackward = false;
    break;
    case 'KeyA':
      moveLeft = false;
    break;
    case 'KeyD':
      moveRight = false;
    break;
    case 'Space':
      moveUp = false;
    break;
  }
}

function onPointerLockChange() {
  if (controls.isLocked) {
    controls.enabled = true;
  } else {
    controls.enabled = false;
  }
  moveUp = false
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function createRandomCube() {
  const size = Math.random() * 2;
  const geometry = new THREE.BoxGeometry(size, size, size);
  const color = new THREE.Color(Math.random(), Math.random(), Math.random());
  const material = new THREE.MeshLambertMaterial({ color });
  const cube = new THREE.Mesh(geometry, material);

  cube.position.set(
    (Math.random() - 0.5) * 100,
    size / 2,
    (Math.random() - 0.5) * 100
  );

  // cubes.push(cube);
  const cubeShape = new CANNON.Box(new CANNON.Vec3(size / 2, size / 2, size / 2));
  const cubeBody = new CANNON.Body({
    mass: 0,
    shape: cubeShape,
    position: new CANNON.Vec3(cube.position.x, cube.position.y, cube.position.z)
  });
  world.addBody(cubeBody);
  cubes.push({ mesh: cube, body: cubeBody });
  return cube;
}

function randomCubeManagement() {
  if (Math.random() < 0.05) {
    const cube = createRandomCube();
    scene.add(cube);

    setTimeout(() => {
      scene.remove(cube);
      cubes = cubes.filter((c) => c !== cube);
      cube.geometry.dispose();
      cube.material.dispose();
    }, Math.random() * 5000 + 2000);
  }
}

randomCubeManagement();

/*
function detectCollision(positionChange) {
  const newPosition = controls.getObject().position.clone().add(positionChange);
  const smallerPlayerBoxSize = new THREE.Vector3(0.45, 1.75, 0.45);
  playerBox.setFromCenterAndSize(newPosition, smallerPlayerBoxSize);

  for (let cube of cubes) {
    const cubeBox = new THREE.Box3().setFromObject(cube);

    if (playerBox.intersectsBox(cubeBox)) {
      const playerBottom = playerBox.min.y;
      const cubeTop = cubeBox.max.y;

      if (positionChange.y < 0 && playerBottom >= cubeTop) {
        // Allow landing on top of the cube
        controls.getObject().position.y = cubeTop + 1.8;
        return false;
      } else {
        // Block movement for side collisions
        return true;
      }
    }
  }

  return false;
}
*/

function createGround() {
  const groundShape = new CANNON.Plane();
  const groundBody = new CANNON.Body({ mass: 0, shape: groundShape });
  groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
  world.addBody(groundBody);
}

function shoot() {
  const radius = 0.1;
  const speed = 50;
  const bulletGeometry = new THREE.SphereGeometry(radius);
  const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
  const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
  bullet.position.copy(controls.getObject().position);
  scene.add(bullet);

  const bulletShape = new CANNON.Sphere(radius);
  const bulletBody = new CANNON.Body({
    mass: 1,
    shape: bulletShape,
    position: new CANNON.Vec3(bullet.position.x, bullet.position.y, bullet.position.z)
  });
  const direction = controls.getDirection(new THREE.Vector3()).normalize();
  bulletBody.velocity.set(direction.x * speed, direction.y * speed, direction.z * speed);
  world.addBody(bulletBody);
  bullets.push({ mesh: bullet, body: bulletBody });

  bulletBody.addEventListener('collide', (e) => {
    const cube = cubes.find((cubeObj) => cubeObj.body.id === e.body.id);
    if (cube) {
      scene.remove(cube.mesh);
      world.remove(cube.body);
      cubes = cubes.filter((c) => c !== cube);
      cube.mesh.geometry.dispose();
      cube.mesh.material.dispose();
    }
    scene.remove(bullet);
    world.remove(bulletBody);
    bullets = bullets.filter((b) => b !== bullet);
    bullet.geometry.dispose();
    bullet.material.dispose();
  });
}

document.addEventListener('mousedown', (e) => {
  if (e.button === 0 && controls.isLocked) {
    shoot();
  }
});

function animate() {
  requestAnimationFrame(animate);

  let velocity = new THREE.Vector3();
  let direction = new THREE.Vector3();
  // let speed = 0.1;
  if (moveBackward) velocity.z -= speed;
  if (moveForward) velocity.z += speed;
  if (moveRight) velocity.x -= speed;
  if (moveLeft) velocity.x += speed;

  if (moveUp) {
    velocityY += gravity;
  } else if (controls.getObject().position.y > 1.8) {
    velocityY = Math.max(velocityY + gravity, -jumpSpeed);
  } else {
    velocityY = 0;
    controls.getObject().position.y = 1.8; // Ensure the player stays on the ground
  }

  const positionChange = new THREE.Vector3(velocity.x, velocityY, velocity.z);
  const verticalChange = new THREE.Vector3(0, velocityY, 0);

  if (controls.isLocked) {
    const playerDirection = controls.getDirection(direction).normalize();
    const sideDirection = new THREE.Vector3(-playerDirection.z, 0, playerDirection.x).normalize();

    playerBody.velocity.x = 0;
    playerBody.velocity.z = 0;
    
    if (moveForward) {
      playerBody.velocity.x += playerDirection.x * speed;
      playerBody.velocity.z += playerDirection.z * speed;
    }
    if (moveBackward) {
      playerBody.velocity.x -= playerDirection.x * speed;
      playerBody.velocity.z -= playerDirection.z * speed;
    }
    if (moveRight) {
      playerBody.velocity.x += sideDirection.x * speed;
      playerBody.velocity.z += sideDirection.z * speed;
    }
    if (moveLeft) {
      playerBody.velocity.x -= sideDirection.x * speed;
      playerBody.velocity.z -= sideDirection.z * speed;
    }
  }

  world.step(1 / 60);
  controls.getObject().position.copy(playerBody.position);

  cubes.forEach((cubeObj) => {
    cubeObj.mesh.position.copy(cubeObj.body.position);
    cubeObj.mesh.quaternion.copy(cubeObj.body.quaternion);
  });

   bullets.forEach((bulletObj) => {
    bulletObj.mesh.position.copy(bulletObj.body.position);
    bulletObj.mesh.quaternion.copy(bulletObj.body.quaternion);
  });

  randomCubeManagement()
  renderer.render(scene, camera);
}
    </script>
  </body>
</html>

