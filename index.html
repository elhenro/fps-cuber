<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Random Cuber</title>
    <style>
body {
  margin: 0;
}
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://rawcdn.githack.com/mrdoob/three.js/r128/examples/js/controls/PointerLockControls.js"></script>
    <script>
let camera, scene, renderer, controls;
let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let moveUp = true;
let velocityY = 0;
const gravity = -0.15;
const jumpSpeed = 2;

let cubes = [];
const playerBox = new THREE.Box3();

init();
animate();

function init() {
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);
  scene.add(new THREE.GridHelper(100, 100));

  let light = new THREE.PointLight(0xffffff, 1);
  camera.add(light);
  scene.add(camera);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  controls = new THREE.PointerLockControls(camera, renderer.domElement);
  document.addEventListener('click', () => controls.lock());
  controls.addEventListener('lock', onPointerLockChange);
  controls.addEventListener('unlock', onPointerLockChange);
  controls.getObject().position.set(0, 1.8, 0);

  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keyup', onKeyUp);

  window.addEventListener('resize', onWindowResize);
}

function onKeyDown(event) {
  switch (event.code) {
    case 'KeyW':
      moveForward = true;
    break;
    case 'KeyS':
      moveBackward = true;
    break;
    case 'KeyA':
      moveLeft = true;
    break;
    case 'KeyD':
      moveRight = true;
    break;
    case 'Space':
      if (!moveUp && controls.getObject().position.y <= 1.8) {
      moveUp = true;
      velocityY = jumpSpeed;
    }
    break;
  }
}

function onKeyUp(event) {
  switch (event.code) {
    case 'KeyW':
      moveForward = false;
    break;
    case 'KeyS':
      moveBackward = false;
    break;
    case 'KeyA':
      moveLeft = false;
    break;
    case 'KeyD':
      moveRight = false;
    break;
    case 'Space':
      moveUp = false;
    break;
  }
}

function onPointerLockChange() {
  if (controls.isLocked) {
    controls.enabled = true;
  } else {
    controls.enabled = false;
  }
  moveUp = false
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function createRandomCube() {
  const size = Math.random() * 2;
  const geometry = new THREE.BoxGeometry(size, size, size);
  const color = new THREE.Color(Math.random(), Math.random(), Math.random());
  const material = new THREE.MeshLambertMaterial({ color });
  const cube = new THREE.Mesh(geometry, material);

  cube.position.set(
    (Math.random() - 0.5) * 100,
    size / 2,
    (Math.random() - 0.5) * 100
  );

  cubes.push(cube);
  return cube;
}

function randomCubeManagement() {
  if (Math.random() < 0.05) {
    const cube = createRandomCube();
    scene.add(cube);

    setTimeout(() => {
      scene.remove(cube);
      cubes = cubes.filter((c) => c !== cube);
      cube.geometry.dispose();
      cube.material.dispose();
    }, Math.random() * 5000 + 2000);
  }
}

randomCubeManagement();

function detectCollision(positionChange) {
  const newPosition = controls.getObject().position.clone().add(positionChange);
  const smallerPlayerBoxSize = new THREE.Vector3(0.45, 1.75, 0.45);
  playerBox.setFromCenterAndSize(newPosition, smallerPlayerBoxSize);

  for (let cube of cubes) {
    const cubeBox = new THREE.Box3().setFromObject(cube);

    if (playerBox.intersectsBox(cubeBox)) {
      const playerBottom = playerBox.min.y;
      const cubeTop = cubeBox.max.y;

      if (positionChange.y < 0 && playerBottom >= cubeTop) {
        // Allow landing on top of the cube
        controls.getObject().position.y = cubeTop + 1.8;
        return false;
      } else {
        // Block movement for side collisions
        return true;
      }
    }
  }

  return false;
}


function animate() {
  requestAnimationFrame(animate);

  let velocity = new THREE.Vector3();
  let direction = new THREE.Vector3();
  let speed = 0.1;
  if (moveBackward) velocity.z -= speed;
  if (moveForward) velocity.z += speed;
  if (moveLeft) velocity.x -= speed;
  if (moveRight) velocity.x += speed;

  if (moveUp) {
    velocityY += gravity;
  } else if (controls.getObject().position.y > 1.8) {
    velocityY = Math.max(velocityY + gravity, -jumpSpeed);
  } else {
    velocityY = 0;
    controls.getObject().position.y = 1.8; // Ensure the player stays on the ground
  }

  const positionChange = new THREE.Vector3(velocity.x, velocityY, velocity.z);
  const verticalChange = new THREE.Vector3(0, velocityY, 0);

  // Check for vertical collisions separately
  if (!detectCollision(verticalChange)) {
    controls.getObject().position.y += velocityY;
  } else {
    // Ensure the player is on the ground when a vertical collision occurs
    controls.getObject().position.y = Math.ceil(controls.getObject().position.y / 2) * 2 - 1.8;
    moveUp = false;
  }

  // Check for horizontal collisions
  if (!detectCollision(positionChange)) {
    controls.moveRight(velocity.x);
    controls.moveForward(velocity.z);
  }


  randomCubeManagement()
  renderer.render(scene, camera);
}
    </script>
  </body>
</html>

