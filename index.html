<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Music generated by Mubert https://mubert.com/render -->
  <title>Random Cuber</title>
  <style>
    body {
      margin: 0;
    }
    canvas {
      display: block;
    }
    /* crosshair */
    #crosshair {
      position: fixed;
      width: 10px;
      height: 10px;
      border: 1px solid white;
      background-color: rgba(0, 0, 0, 0.5);
      top: 50%;
      left: 50%;
      margin-top: -5px;
      margin-left: -5px;
      pointer-events: none;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="crosshair"></div>
  <audio id="hit-sound" preload="auto">
    <source src="hit.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="oof-sound" preload="auto">
    <source src="oof.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="jump-sound" preload="auto">
    <source src="jump.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="bling-sound" preload="auto">
    <source src="bling.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="dead-sound" preload="auto">
    <source src="dead.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="bg-music" loop>
    <source src="vaporwave_electro_parcour_space.mp3" type="audio/mpeg">
  </audio>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://rawcdn.githack.com/mrdoob/three.js/r128/examples/js/controls/PointerLockControls.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"
    integrity="sha512-avLcnGxl5mqAX/wIKERdb1gFNkOLHh2W5JNCfJm5OugpEPBz7LNXJJ3BDjjwO00AxEY1MqdNjtEmiYhKC0ld7g=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    let camera, scene, renderer, controls
    let moveForward = false
    let moveBackward = false
    let moveLeft = false
    let moveRight = false
    let moveUp = true
    let velocityY = 0

    const gravity = -9.81
    const jumpSpeed = 5
    const speed = 4

    let isMouseDown = false
    let lastFireTime = 0
    const fireInterval = 1000 / 600 * 60

    let worldObjects = []
    const playerBox = new THREE.Box3()

    let world
    let playerBody = createPlayerBody()
    let bullets = []
    let playerHealthPoints = 3
    let isDead = false
    let healthDisplay

    let score = 0

    // collision groups
    const playerCollisionGroup = 1
    const bulletCollisionGroup = 2
    const objectCollisionGroup = 4
    const groundCollisionGroup = 8

    // bullets never collide with player
    playerBody.collisionFilterGroup = playerCollisionGroup
    playerBody.collisionFilterMask = ~bulletCollisionGroup

    const worldObjectsSpeed = 2.5

    // sounds
    const bgMusic = document.getElementById('bg-music')

    init()
    animate()

    function init() {
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
      scene = new THREE.Scene()
      scene.background = new THREE.Color(0xffffff)
      scene.add(new THREE.GridHelper(100, 100))

      let light = new THREE.PointLight(0xffffff, 1)
      camera.add(light)
      scene.add(camera)

      world = new CANNON.World()
      world.gravity.set(0, gravity, 0)
      world.broadphase = new CANNON.NaiveBroadphase()
      world.solver.iterations = 10

      createGround()

      world.addBody(playerBody)

      renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth, window.innerHeight)
      document.body.appendChild(renderer.domElement)

      controls = new THREE.PointerLockControls(camera, renderer.domElement)
      document.addEventListener('click', () => controls.lock())
      controls.addEventListener('lock', onPointerLockChange)
      controls.addEventListener('unlock', onPointerLockChange)
      controls.getObject().position.set(0, 1.8, 0)
      document.addEventListener('keydown', onKeyDown)
      document.addEventListener('keyup', onKeyUp)
      window.addEventListener('resize', onWindowResize)

      playerBody.addEventListener('collide', (e) => {
        const contact = e.contact
        const cube = worldObjects.find((cubeObj) => cubeObj.body.id === e.body.id)
        if (cube) { // Top or bottom of the cube was hit
          if (contact.ni.y > 0.5 || contact.ni.y < -0.5) {
            playerHealthPoints -= 1
            playSound('oof')
            if (playerHealthPoints <= 0) {
              gameOver()
            }
          } else { }
        } else { // floor collision
            if (playerHealthPoints <= 0) {
              gameOver()
            }
        }
      })

      healthDisplay = document.createElement('div')
      healthDisplay.style.position = 'absolute'
      healthDisplay.style.top = '10px'
      healthDisplay.style.left = '10px'
      healthDisplay.style.color = 'white'
      healthDisplay.style.fontFamily = 'Arial, sans-serif'
      healthDisplay.style.fontSize = '20px'
      healthDisplay.style.zIndex = 100
      document.body.appendChild(healthDisplay)

      scoreDisplay = document.createElement('div')
      scoreDisplay.style.position = 'absolute'
      scoreDisplay.style.top = '10px'
      scoreDisplay.style.right = '10px'
      scoreDisplay.style.color = 'white'
      scoreDisplay.style.fontFamily = 'Arial, sans-serif'
      scoreDisplay.style.fontSize = '20px'
      scoreDisplay.style.zIndex = 100
      document.body.appendChild(scoreDisplay)
    }

    function mapIntToHeartString(num) {
      switch (num) {
        case 3:
          return "❤️❤️❤️"
        case 2:
          return "❤️❤️"
        case 1:
          return "❤️"
        case 0:
          return ""
        default:
          return ""
      }
    }

    function updateHealthDisplay() {
      healthDisplay.innerHTML = mapIntToHeartString(playerHealthPoints)
    }

    function updateScoreDisplay() {
      scoreDisplay.innerHTML = `✴️ ${score}`
    }

    function onKeyDown(event) {
      switch (event.code) {
        case 'KeyW':
          moveForward = true
          bgMusic.play()
          break
        case 'KeyS':
          moveBackward = true
          break
        case 'KeyA':
          moveLeft = true
          break
        case 'KeyD':
          moveRight = true
          break
        case 'Space':
          if (!moveUp && controls.getObject().position.y <= 1.8) {
            moveUp = true
            playSound('jump')
            playerBody.applyImpulse(new CANNON.Vec3(0, jumpSpeed * playerBody.mass, 0), playerBody.position)
          }
          break
      }
    }

    function onKeyUp(event) {
      switch (event.code) {
        case 'KeyW':
          moveForward = false
          break
        case 'KeyS':
          moveBackward = false
          break
        case 'KeyA':
          moveLeft = false
          break
        case 'KeyD':
          moveRight = false
          break
        case 'Space':
          moveUp = false
          break
      }
    }

    function playSound(type) {
      const sound = document.getElementById(`${type}-sound`)
      const clonedSound = sound.cloneNode(true)
      clonedSound.play()
    }

    function onPointerLockChange() {
      if (controls.isLocked) {
        controls.enabled = true
        if (playerHealthPoints > 0) {
          bgMusic.play()
        }
      } else {
        controls.enabled = false
        bgMusic.pause()
      }
      moveUp = false
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
    }

    function createRandomCube() {
      const size = Math.random() * 2
      const geometry = new THREE.BoxGeometry(size, size, size)
      const color = new THREE.Color(Math.random(), Math.random(), Math.random())
      const material = new THREE.MeshLambertMaterial({ color })
      const cube = new THREE.Mesh(geometry, material)
      cube.position.set(
        (Math.random() - 0.5) * 100,
        size / 2,
        (Math.random() - 0.5) * 100
      )
      const cubeShape = new CANNON.Box(new CANNON.Vec3(size / 2, size / 2, size / 2))
      const cubeBody = new CANNON.Body({
        mass: 0.3,
        shape: cubeShape,
        position: new CANNON.Vec3(cube.position.x, cube.position.y, cube.position.z),
        collisionFilterGroup: objectCollisionGroup,
        collisionFilterMask: ~0 // Collides with everything
      })
      world.addBody(cubeBody)
      worldObjects.push({ mesh: cube, body: cubeBody })
      return cube
    }

    function randomCubeManagement() {
      if (Math.random() < 0.05) {
        const cube = createRandomCube()
        scene.add(cube)
      }
    }

    function createPlayerBody() {
      return new CANNON.Body({
        mass: 5,
        position: new CANNON.Vec3(0, 1.8, 0),
        shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.9, 0.5))
      })
    }

    function createRandomSphere() {
      const radius = Math.random() * 1
      const geometry = new THREE.SphereGeometry(radius, 32, 32)
      const color = new THREE.Color(Math.random(), Math.random(), Math.random())
      const material = new THREE.MeshLambertMaterial({ color })
      const sphere = new THREE.Mesh(geometry, material)
      sphere.position.set(
        (Math.random() - 0.5) * 100,
        radius,
        (Math.random() - 0.5) * 100
      )
      const sphereShape = new CANNON.Sphere(radius)
      const sphereBody = new CANNON.Body({
        mass: 1,
        shape: sphereShape,
        position: new CANNON.Vec3(sphere.position.x, sphere.position.y, sphere.position.z),
        collisionFilterGroup: objectCollisionGroup,
        collisionFilterMask: ~0 // Collides with everything
      })
      world.addBody(sphereBody)
      worldObjects.push({ mesh: sphere, body: sphereBody })
      return sphere
    }

    function randomSphereManagement() {
      if (Math.random() < 0.05) {
        const sphere = createRandomSphere()
        scene.add(sphere)
      }
    }

    function createGround() {
      const groundShape = new CANNON.Plane()
      const groundBody = new CANNON.Body({
        mass: 0,
        shape: groundShape,
        collisionFilterGroup: groundCollisionGroup,
        collisionFilterMask: ~0 // Collides with everything
      })
      groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2)
      world.addBody(groundBody)
    }

    function moveWorldOjectsTowardsPlayer() {
      if (moveUp) return
      const playerPosition = controls.getObject().position.clone()
      worldObjects.forEach(obj => {
        const objPosition = obj.body.position.clone()
        const direction = new THREE.Vector3().subVectors(playerPosition, objPosition).normalize()
        obj.body.applyForce(direction.multiplyScalar(worldObjectsSpeed), objPosition)
      })
    }

    function fireBullet() {
      const radius = 0.2
      const speed = 111
      const bulletGeometry = new THREE.SphereGeometry(radius)
      const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff })
      const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial)
      const bulletOffset = new THREE.Vector3(0.1, -0.3, 0)
      let bulletStartPosition = controls.getObject().position.clone().add(bulletOffset)
      bullet.position.copy(bulletStartPosition)
      scene.add(bullet)
      const bulletShape = new CANNON.Sphere(radius)
      const bulletBody = new CANNON.Body({
        mass: 1,
        shape: bulletShape,
        position: new CANNON.Vec3(bullet.position.x, bullet.position.y, bullet.position.z),
        collisionFilterGroup: bulletCollisionGroup,
        collisionFilterMask: objectCollisionGroup | groundCollisionGroup // Collides with cubes, spheres, and ground
      })
      const direction = controls.getDirection(new THREE.Vector3()).normalize()
      bulletBody.velocity.set(direction.x * speed, direction.y * speed, direction.z * speed)
      world.addBody(bulletBody)
      bullets.push({ mesh: bullet, body: bulletBody })
      bulletBody.addEventListener('collide', (e) => {
        const cube = worldObjects.find((cubeObj) => cubeObj.body.id === e.body.id)
        if (cube) {
          scene.remove(cube.mesh)
          world.remove(cube.body)
          worldObjects = worldObjects.filter((c) => c !== cube)
          cube.mesh.geometry.dispose()
          cube.mesh.material.dispose()
          score += 1
          updateScoreDisplay()
          playSound('hit')
        }
        setTimeout(() => {
          scene.remove(bullet)
          world.remove(bulletBody)
          bullets = bullets.filter((b) => b !== bullet)
          bullet.geometry.dispose()
          bullet.material.dispose()
        }, 5000)
      })
    }

    function fireBulletIfNeeded() {
      const currentTime = performance.now()
      if (isMouseDown && currentTime - lastFireTime >= fireInterval) {
        fireBullet()
        lastFireTime = currentTime
      }
    }

    function updateScreenTint() {
      const tintIntensity = 1 - playerHealthPoints / 3
      const currentTint = new THREE.Color(tintIntensity, 0, 0)
      scene.background.lerp(currentTint, 0.1)
    }

    function gameOver() {
      const overlay = document.createElement('div')
      overlay.style.position = 'absolute'
      overlay.style.top = 0
      overlay.style.left = 0
      overlay.style.width = '100%'
      overlay.style.height = '100%'
      overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.75)'
      overlay.style.display = 'flex'
      overlay.style.justifyContent = 'center'
      overlay.style.alignItems = 'center'
      overlay.style.flexDirection = 'column'
      overlay.style.zIndex = 1000
      document.body.appendChild(overlay)

      const gameOverText = document.createElement('h1')
      gameOverText.innerText = 'GAME OVER'
      gameOverText.style.color = 'white'
      gameOverText.style.marginBottom = '1rem'
      overlay.appendChild(gameOverText)

      const restartButton = document.createElement('button')
      restartButton.innerText = 'Restart'
      restartButton.style.padding = '0.5rem 1rem'
      restartButton.style.fontSize = '1.25rem'
      overlay.appendChild(restartButton)

      restartButton.addEventListener('click', () => {
        location.reload()
        isDead = false
        bgMusic.play()
      })

      if (isDead) return
      isDead = true
      playSound('dead')
      bgMusic.pause()
      controls.unlock()
    }

    document.addEventListener('mousedown', (event) => { isMouseDown = true })
    document.addEventListener('mouseup', (event) => { isMouseDown = false })

    function animate() {
      if (isDead) return
      requestAnimationFrame(animate)
      updateHealthDisplay()
      let velocity = new THREE.Vector3()
      let direction = new THREE.Vector3()
      if (moveBackward) velocity.z -= speed
      if (moveForward) velocity.z += speed
      if (moveRight) velocity.x -= speed
      if (moveLeft) velocity.x += speed
      if (moveUp) {
        velocityY += gravity
      } else if (controls.getObject().position.y > 1.8) {
        velocityY = Math.max(velocityY + gravity, -jumpSpeed)
      } else {
        velocityY = 0
        controls.getObject().position.y = 1.8 // stay above floor
      }
      const positionChange = new THREE.Vector3(velocity.x, velocityY, velocity.z)
      const verticalChange = new THREE.Vector3(0, velocityY, 0)

      if (controls.isLocked) {
        const playerDirection = controls.getDirection(direction).normalize()
        const sideDirection = new THREE.Vector3(-playerDirection.z, 0, playerDirection.x).normalize()

        playerBody.velocity.x = 0
        playerBody.velocity.z = 0

        if (moveForward) {
          playerBody.velocity.x += playerDirection.x * speed
          playerBody.velocity.z += playerDirection.z * speed
        }
        if (moveBackward) {
          playerBody.velocity.x -= playerDirection.x * speed
          playerBody.velocity.z -= playerDirection.z * speed
        }
        if (moveRight) {
          playerBody.velocity.x += sideDirection.x * speed
          playerBody.velocity.z += sideDirection.z * speed
        }
        if (moveLeft) {
          playerBody.velocity.x -= sideDirection.x * speed
          playerBody.velocity.z -= sideDirection.z * speed
        }
      }
      world.step(1 / 60)

      worldObjects.forEach((obj) => {
        obj.mesh.position.copy(obj.body.position)
        obj.mesh.quaternion.copy(obj.body.quaternion)
      })

      bullets.forEach((bulletObj) => {
        bulletObj.mesh.position.copy(bulletObj.body.position)
        bulletObj.mesh.quaternion.copy(bulletObj.body.quaternion)
      })

      controls.getObject().position.copy(playerBody.position)

      randomCubeManagement()
      randomSphereManagement()
      updateScreenTint()
      fireBulletIfNeeded()
      moveWorldOjectsTowardsPlayer()
      renderer.render(scene, camera)
    }
  </script>
</body>
</html>